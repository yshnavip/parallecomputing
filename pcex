1) #include <stdio.h>
#include <stdlib.h>
#include <omp.h>
#include <time.h>
#define MIN_SIZE 1000
void merge(int arr[], int left, int mid, int right) {
int i, j, k;
int n1 = mid - left + 1;
int n2 = right - mid;
int *L = (int *)malloc(n1 * sizeof(int));
int *R = (int *)malloc(n2 * sizeof(int));
for (i = 0; i < n1; i++) L[i] = arr[left + i];
for (j = 0; j < n2; j++) R[j] = arr[mid + 1 + j];
i = 0; j = 0; k = left;
while (i < n1 && j < n2) {
if (L[i] <= R[j]) arr[k++] = L[i++];
else arr[k++] = R[j++];
}
while (i < n1) arr[k++] = L[i++];
while (j < n2) arr[k++] = R[j++];
free(L);
free(R) ;
}
void mergeSortSequential(int arr[], int left, int right) {
if (left < right) {
int mid = left + (right - left) / 2;
mergeSortSequential(arr, left, mid);
mergeSortSequential(arr, mid + 1, right);
merge(arr, left, mid, right);
}
}
void mergeSortParallel(int arr[], int left, int right) {
if ((right - left + 1) <= MIN_SIZE) {
mergeSortSequential(arr, left, right);
return;
}
if (left < right) {
int mid = left + (right - left) / 2;
#pragma omp parallel sections
{
#pragma omp section
{ mergeSortParallel(arr, left, mid); }
#pragma omp section
{ mergeSortParallel(arr, mid + 1, right); }
}
merge(arr, left, mid, right);
}
}
int main() {
int n = 100000;
int *arr_seq = (int *)malloc(n * sizeof(int));
int *arr_par = (int *)malloc(n * sizeof(int));
srand(time(0));
for (int i = 0; i < n; i++) {
arr_par[i] = arr_seq[i] = rand() % 10000;
printf("Sorting %d elements ... \n\n", n);
double start_time = omp_get_wtime();
mergeSortSequential(arr_seq, 0, n - 1);
double time_seq = omp_get_wtime() - start_time;
printf("Sequential Merge Sort Time: %f seconds\n", time_seq);
start_time = omp_get_wtime();
mergeSortParallel(arr_par, 0, n - 1);
double time_par = omp_get_wtime() - start_time;
printf("Parallel Merge Sort Time: %f seconds\n", time_par);
printf("\nDifference (Sequential - Parallel): %f seconds\n", time_seq - time_par);
if (time_par > 0) printf("Speedup: %.2fx\n", time_seq / time_par);
printf("\nVerification: First 20 elements of the sorted array: \n");
for (int i = 0; i < (n < 20 ? n : 20); i++) printf("%d ", arr_par[i]);
printf("\n");
free(arr_seq);
free(arr_par);
return 0;
}

2) #include <stdio.h>
#include <omp.h>
int main() {
int num_iterations;
printf("Enter the number of iterations: ");
scanf("%d", &num_iterations);
#pragma omp parallel
#pragma omp for schedule(static,2)
for (int i = 0; i < num_iterations; i++) {
printf("Thread %d: Iteration %d\n", omp_get_thread_num(), i);
}
return 0;
}


3) #include <stdio.h>
#include <omp.h>
int fib(int n) {
int i, j;
if (n < 2)
return n;
else {
#pragma omp task shared(i) firstprivate(n)
i = fib(n - 1);
#pragma omp task shared(j) firstprivate(n)
j= fib(n - 2);
#pragma omp taskwait
return i + j;
}
}
int main() {
int n;
printf("Enter the Fibonacci number to calculate: ");
scanf("%d", &n);
omp_set_dynamic(0);
omp_set_num_threads(4);
#pragma omp parallel shared(n)
{
#pragma omp single
printf ("fib(%d) = %d\n", n, fib(n));
return 0;
}


4) #include <stdio.h>
#include <stdlib.h>
#include <omp.h>
#include <math.h>
int is_prime(int num) {
if (num <= 1) return 0;
if (num == 2) return 1;
if (num % 2 == 0) return 0;
for (int i = 3; i <= sqrt(num); i += 2) {
if (num % i == 0) return 0;
}
return 1;
}
int main() {
int n;
printf("Enter the upper limit (n) to find prime numbers: ");
scanf("%d", &n);
if (n < 2) {
printf("There are no prime numbers up to %d. \n", n);
return 0;
printf("\nFinding prime numbers from 1 to %d ... \n", n);
double start_time = omp_get_wtime();
int sequential_prime_count = 0;
for (int i = 1; i <= n; i++) {
if (is_prime(i)) sequential_prime_count++;
double time_seq = omp_get_wtime() - start_time;
printf("\nSequential: Found %d primes in %f seconds\n", sequential_prime_count, time_seq);
start_time = omp_get_wtime();
int parallel_prime_count = 0;
#pragma omp parallel for reduction(+:parallel_prime_count) schedule(dynamic)
for (int i = 1; i <= n; i++) {
if (is_prime(i)) parallel_prime_count++;
double time_par = omp_get_wtime() - start_time;
printf("Parallel:
Found %d primes in %f seconds\n", parallel_prime_count, time_par);
if (time_par > 0 && time_seq > 0) {
printf("\nSpeedup: %.2fx\n", time_seq / time_par);
return 0;
}



5) #include <stdio.h>
#include <mpi.h>
int main(int argc, char *argv[]) {
int rank, size;
int number;
// Initialize the MPI environment
MPI_Init(&argc, &argv);
// Get the number of processes
MPI_Comm_size(MPI_COMM_WORLD, &size);
// Get the rank of the process
MPI_Comm_rank(MPI_COMM_WORLD, &rank);
if (size < 2) {
if (rank == 0) {
printf("This program requires at least 2 processes. \n");
}
MPI_Finalize();
return 0;
if (rank == 0) {
// Process 0 sends a number to Process 1
number = 42;
printf("Process 0 is sending number %d to Process 1\n", number);
MPI_Send(&number, 1, MPI_INT, 1, 0, MPI_COMM_WORLD);
} else if (rank == 1) {
// Process 1 receives a number from Process 0
MPI_Recv(&number, 1, MPI_INT, 0, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE) ;
printf("Process 1 received number %d from Process 0\n", number);
}
// Finalize the MPI environment
MPI_Finalize();
return 0;
}


6) #include <stdio.h>
#include <mpi.h>
int main(int argc, char *argv[]) {
int rank, data_send, data_recv;
MPI_Init(&argc, &argv);
MPI_Comm_rank(MPI_COMM_WORLD, &rank);
data_send = rank;
if (rank == 0) {
MPI_Send(&data_send, 1, MPI_INT, 1, 0, MPI_COMM_WORLD);
MPI_Recv(&data_recv, 1, MPI_INT, 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE) ;
} else if (rank == 1) {
MPI_Send(&data_send, 1, MPI_INT, 0, 0, MPI_COMM_WORLD);
MPI_Recv(&data_recv, 1, MPI_INT, 0, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE) ;
}
printf("Process %d received %d\n", rank, data_recv);
MPI_Finalize();
return 0;
}


7) #include <stdio.h>
#include <mpi.h>
int main(int argc, char ** argv) {
int rank, data = 0;
MPI_Init(&argc, &argv);
MPI_Comm_rank(MPI_COMM_WORLD, &rank);
if (rank == 0)
data = 100;
MPI_Bcast(&data, 1, MPI_INT, 0, MPI_COMM_WORLD);
printf("Process %d received data: %d\n", rank, data);
MPI_Finalize();
return 0;
}



8) #include <stdio.h>
#include <mpi.h>
int main(int argc, char ** argv) {
int rank, size, data[4] = {10, 20, 30, 40}, recv;
MPI_Init(&argc, &argv);
MPI_Comm_rank(MPI_COMM_WORLD, &rank);
MPI_Comm_size(MPI_COMM_WORLD, &size);
MPI_Scatter(data, 1, MPI_INT, &recv, 1, MPI_INT, 0, MPI_COMM_WORLD) ;
recv += 1;
MPI_Gather(&recv, 1, MPI_INT, data, 1, MPI_INT, 0, MPI_COMM_WORLD);
if (rank == 0) {
printf("Gathered data: ");
for (int i = 0; i < size; i++) printf("%d ", data[i]);
printf("\n");
MPI_Finalize();
return 0;
}


9) #include <stdio.h>
#include <mpi.h>
int main(int argc, char ** argv) {
int rank, value, sum, prod, max, min;
MPI_Init(&argc, &argv);
MPI_Comm_rank(MPI_COMM_WORLD, &rank);
value = rank + 1;
MPI_Reduce(&value, &sum, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);
MPI_Allreduce(&value, &prod, 1, MPI_INT, MPI_PROD, MPI_COMM_WORLD);
MPI_Allreduce(&value, &max, 1, MPI_INT, MPI_MAX, MPI_COMM_WORLD);
MPI_Allreduce(&value, &min, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);
if (rank == 0)
printf("Reduce SUM (only root): %d\n", sum);
printf("Allreduce PROD (rank %d): %d\n", rank, prod);
printf("Allreduce MAX
(rank %d): %d\n", rank, max);
printf("Allreduce MIN
(rank %d): %d\n", rank, min);
MPI_Finalize();
return 0;
}
